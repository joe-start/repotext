This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-02T15:21:56.390Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    ci.yml
repotext/
  tests/
    test_compressor.py
    test_diff_generator.py
    test_security.py
    test_utils.py
  cli.py
  compressor.py
  diff_generator.py
  file_handler.py
  main.py
  packer.py
  security.py
  tokenizer.py
  utils.py
.gitignore
README.md
requirements.txt
setup.py

================================================================
Repository Files
================================================================

================
File: .github/workflows/ci.yml
================
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.7, 3.8, 3.9]

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest

================
File: repotext/tests/test_compressor.py
================
import unittest
from repotext.compressor import compress_text, decompress_text

class TestCompressor(unittest.TestCase):

    def test_compression_decompression(self):
        original_text = "This is a test string for compression and decompression."
        compressed = compress_text(original_text)
        decompressed = decompress_text(compressed)
        
        self.assertNotEqual(original_text, compressed)
        self.assertEqual(original_text, decompressed)

    def test_compression_reduces_size(self):
        long_text = "This is a long string " * 1000
        compressed = compress_text(long_text)
        
        self.assertLess(len(compressed), len(long_text))

if __name__ == '__main__':
    unittest.main()

================
File: repotext/tests/test_diff_generator.py
================
import unittest
import tempfile
import os
from repotext.diff_generator import generate_diff

class TestDiffGenerator(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        os.rmdir(self.temp_dir)

    def test_generate_diff(self):
        old_content = ['line 1', 'line 2', 'line 3']
        new_content = ['line 1', 'line 2 modified', 'line 4']

        # First run to create the .last_repotext_pack.txt file
        generate_diff(old_content, self.temp_dir)

        # Generate diff
        diff = generate_diff(new_content, self.temp_dir)

        self.assertIn('  line 1', diff)
        self.assertIn('- line 2', diff)
        self.assertIn('+ line 2 modified', diff)
        self.assertIn('- line 3', diff)
        self.assertIn('+ line 4', diff)

if __name__ == '__main__':
    unittest.main()

================
File: repotext/tests/test_security.py
================
import unittest
from repotext.security import check_for_sensitive_info

class TestSecurity(unittest.TestCase):

    def test_api_key_redaction(self):
        content = "My API key is AbCdEfGhIjKlMnOpQrStUvWxYz123456789"
        result = check_for_sensitive_info(content)
        self.assertIn('[API_KEY_REDACTED]', result)
        self.assertNotIn('AbCdEfGhIjKlMnOpQrStUvWxYz123456789', result)

    def test_password_redaction(self):
        content = 'password = "mysecretpassword"\npassword: hardertoguess'
        result = check_for_sensitive_info(content)
        self.assertIn('[PASSWORD_REDACTED]', result)
        self.assertNotIn('mysecretpassword', result)
        self.assertNotIn('hardertoguess', result)

if __name__ == '__main__':
    unittest.main()

================
File: repotext/tests/test_utils.py
================
import unittest
import tempfile
import os
from repotext.utils import get_file_order, analyze_dependencies, get_project_structure

class TestUtils(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        
        # Create some test files
        open(os.path.join(self.temp_dir, 'main.py'), 'w').close()
        open(os.path.join(self.temp_dir, 'utils.py'), 'w').close()
        open(os.path.join(self.temp_dir, 'test_main.py'), 'w').close()

    def tearDown(self):
        for root, dirs, files in os.walk(self.temp_dir, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            for name in dirs:
                os.rmdir(os.path.join(root, name))
        os.rmdir(self.temp_dir)

    def test_get_file_order(self):
        order = get_file_order(self.temp_dir)
        self.assertEqual(len(order), 3)
        self.assertTrue(order[0].endswith('main.py'))
        self.assertTrue(order[-1].endswith('test_main.py'))

    def test_analyze_dependencies(self):
        with open(os.path.join(self.temp_dir, 'main.py'), 'w') as f:
            f.write("import os\nfrom utils import helper")
        
        deps = analyze_dependencies(self.temp_dir)
        self.assertIn('os', deps)
        self.assertIn('utils', deps)

    def test_get_project_structure(self):
        structure = get_project_structure(self.temp_dir)
        self.assertIn('main.py', structure)
        self.assertIn('utils.py', structure)
        self.assertIn('test_main.py', structure)

if __name__ == '__main__':
    unittest.main()

================
File: repotext/cli.py
================
import click
import os
from .packer import pack_repository
from .compressor import compress_text, decompress_text

@click.command()
@click.argument('repo_path', type=click.Path(exists=True))
@click.option('--output', '-o', default='repotext_output.txt', help='Output file name')
@click.option('--exclude', '-e', multiple=True, help='Patterns to exclude')
@click.option('--diff', is_flag=True, help='Generate diff from last pack')
@click.option('--compress', is_flag=True, help='Compress the output')
@click.option('--format', type=click.Choice(['txt', 'md', 'json']), default='txt', help='Output format')
def main(repo_path, output, exclude, diff, compress, format):
    """Pack a repository into a single AI-friendly file."""
    try:
        result = pack_repository(repo_path, output, exclude, diff, compress, format)
        click.echo(f"Repository packed successfully: {result}")
    except Exception as e:
        click.echo(f"Error: {str(e)}", err=True)

if __name__ == '__main__':
    main()

================
File: repotext/compressor.py
================
import gzip
import base64

def compress_text(text):
    """
    Compress the given text using gzip and encode it in base64.
    """
    compressed = gzip.compress(text.encode('utf-8'))
    return base64.b64encode(compressed).decode('utf-8')

def decompress_text(compressed_text):
    """
    Decompress the given base64-encoded gzipped text.
    """
    decoded = base64.b64decode(compressed_text.encode('utf-8'))
    return gzip.decompress(decoded).decode('utf-8')

================
File: repotext/diff_generator.py
================
import difflib
import os

def generate_diff(new_content, repo_path):
    """
    Generate a diff between the new content and the last packed content.
    """
    last_pack_file = os.path.join(repo_path, '.last_repotext_pack.txt')
    
    if not os.path.exists(last_pack_file):
        # If no previous pack exists, return the full new content
        with open(last_pack_file, 'w') as f:
            f.write('\n'.join(new_content))
        return new_content

    with open(last_pack_file, 'r') as f:
        old_content = f.read().splitlines()

    differ = difflib.Differ()
    diff = list(differ.compare(old_content, new_content))

    # Update the last pack file
    with open(last_pack_file, 'w') as f:
        f.write('\n'.join(new_content))

    return diff

================
File: repotext/file_handler.py
================
def read_file(file_path):
    with open(file_path, 'r') as file:
        return file.read()

def write_output(content, output_file, format):
    with open(output_file, 'w') as file:
        if format == 'json':
            import json
            json.dump({'content': content}, file)
        elif format == 'md':
            file.write(f"# Repository Content\n\n{content}")
        else:
            file.write(content)

================
File: repotext/main.py
================
from .cli import main

if __name__ == '__main__':
    main()

================
File: repotext/packer.py
================
import os
from .file_handler import read_file, write_output
from .security import check_for_sensitive_info
from .tokenizer import count_tokens
from .diff_generator import generate_diff
from .compressor import compress_text
from .utils import get_file_order, analyze_dependencies

def pack_repository(repo_path, output, exclude, diff, compress, format):
    packed_content = []
    total_tokens = 0
    
    # Get intelligent file order
    file_order = get_file_order(repo_path)
    
    for root, dirs, files in os.walk(repo_path):
        for file in file_order:
            if any(file.endswith(ext) for ext in ['.py', '.js', '.java', '.cpp']):  # Add more extensions as needed
                file_path = os.path.join(root, file)
                if not any(file_path.startswith(ex) for ex in exclude):
                    content = read_file(file_path)
                    safe_content = check_for_sensitive_info(content)
                    tokens = count_tokens(safe_content)
                    total_tokens += tokens
                    packed_content.append(f"File: {file_path}\nTokens: {tokens}\n\n{safe_content}\n\n")

    # Add project structure and dependency analysis
    packed_content.insert(0, f"Project Structure:\n{get_project_structure(repo_path)}\n\n")
    packed_content.insert(1, f"Dependency Analysis:\n{analyze_dependencies(repo_path)}\n\n")

    if diff:
        packed_content = generate_diff(packed_content)

    final_content = "".join(packed_content)
    
    if compress:
        final_content = compress_text(final_content)

    write_output(final_content, output, format)
    
    return f"Output written to {output}. Total tokens: {total_tokens}"

================
File: repotext/security.py
================
import re

def check_for_sensitive_info(content):
    """
    Check for and replace sensitive information in the content.
    """
    # Pattern for potential API keys (alphanumeric string of 32-40 characters)
    api_key_pattern = re.compile(r'\b[A-Za-z0-9]{32,40}\b')
    
    # Pattern for potential passwords (any string following "password = " or "password:")
    password_pattern = re.compile(r'(password\s*[=:]\s*)("[^"]+"|\'[^\']+\'|\S+)')
    
    # Replace API keys
    content = api_key_pattern.sub('[API_KEY_REDACTED]', content)
    
    # Replace passwords
    content = password_pattern.sub(r'\1[PASSWORD_REDACTED]', content)
    
    return content

================
File: repotext/tokenizer.py
================
import re

def count_tokens(text):
    """
    A simple tokenizer that splits on whitespace and punctuation.
    This is a basic implementation and may not accurately represent
    the tokenization used by specific AI models.
    """
    # Split on whitespace and punctuation
    tokens = re.findall(r'\b\w+\b|[^\w\s]', text)
    return len(tokens)

================
File: repotext/utils.py
================
import os
import ast

def get_file_order(repo_path):
    """
    Determine an intelligent order for processing files.
    Prioritize main files, then utilities, then tests.
    """
    file_order = []
    for root, _, files in os.walk(repo_path):
        for file in files:
            if file.endswith(('.py', '.js', '.java', '.cpp')):  # Add more extensions as needed
                full_path = os.path.join(root, file)
                if 'main' in file.lower():
                    file_order.insert(0, full_path)
                elif 'test' in file.lower():
                    file_order.append(full_path)
                else:
                    file_order.insert(len(file_order) // 2, full_path)
    return file_order

def analyze_dependencies(repo_path):
    """
    Analyze Python dependencies in the repository.
    """
    dependencies = set()
    for root, _, files in os.walk(repo_path):
        for file in files:
            if file.endswith('.py'):
                with open(os.path.join(root, file), 'r') as f:
                    try:
                        tree = ast.parse(f.read())
                        for node in ast.walk(tree):
                            if isinstance(node, ast.Import):
                                for n in node.names:
                                    dependencies.add(n.name)
                            elif isinstance(node, ast.ImportFrom):
                                dependencies.add(node.module)
                    except SyntaxError:
                        print(f"Couldn't parse {file}")
    return list(dependencies)

def get_project_structure(repo_path):
    """
    Generate a string representation of the project structure.
    """
    structure = []
    for root, dirs, files in os.walk(repo_path):
        level = root.replace(repo_path, '').count(os.sep)
        indent = ' ' * 4 * level
        structure.append(f'{indent}{os.path.basename(root)}/')
        sub_indent = ' ' * 4 * (level + 1)
        for file in files:
            structure.append(f'{sub_indent}{file}')
    return '\n'.join(structure)

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/

# IDE settings
.vscode/
.idea/

================
File: README.md
================
# RepoText

RepoText is an open-source tool that packs your entire repository into a single, AI-friendly file. It's designed to help developers feed their codebase into LLMs/AI tools like Claude, ChatGPT, and Gemini for comprehensive project analysis and advice.

## Features

- Optimized for AI tools like Claude, ChatGPT, etc.
- Includes project and folder structure for AI context
- Provides token counts for each file and the entire repo
- One-command repo packing
- Customizable file inclusion/exclusion
- Security checks to detect and prevent inclusion of sensitive information
- Language and project type agnostic
- Optimized for smallest file size possible
- Intelligent file ordering
- Dependency analysis
- Diff-style output for changes since the last pack

### Using a Virtual Environment (Recommended)

It's recommended to use a virtual environment to avoid conflicts with other Python packages:

1. Create a virtual environment:

python3 -m venv venv

2. Activate the virtual environment:

source venv/bin/activate

3. Install the package:

pip install -e .

4. You can now use RepoText within this virtual environment.

5. When you're done, you can deactivate the virtual environment:

deactivate

## Installation

1. Clone the repository:

git clone https://github.com/yourusername/repotext.git
cd repotext

2. Install the package:

pip install -e .

## Usage

To pack a repository: 

repotext /path/to/your/repo --output packed_repo.txt

Options:
- `--output, -o`: Specify the output file name (default: repotext_output.txt)
- `--exclude, -e`: Patterns to exclude (can be used multiple times)
- `--diff`: Generate diff from last pack
- `--compress`: Compress the output
- `--format`: Output format (txt, md, or json)

Example with options:

repotext /path/to/your/repo -o packed_repo.txt --exclude ".pyc" --exclude "venv/" --diff --compress --format md

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for more details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

================
File: requirements.txt
================
click==8.0.3
pytest==7.3.1

================
File: setup.py
================
from setuptools import setup, find_packages

setup(
    name='repotext',
    version='0.1',
    packages=find_packages(),
    include_package_data=True,
    install_requires=[
        'Click',
    ],
    entry_points={
        'console_scripts': [
            'repotext=repotext.cli:main',
        ],
    },
)
